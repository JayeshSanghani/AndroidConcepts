SOLID Principle

SOLID principles are an object-oriented approach that are applied to software structure design. 
It also ensures that the software is modular, easy to understand, debug, and refactor. 

Single Responsibility Principle (SRP)
Open-Closed Principle (OCP)
Liskov Substitution Principle (LSP)
Interface Segregation Principle (ISP)
Dependency Inversion Principle (DIP)

==> Single Responsibility Principle (SRP)
The single responsibility principle states that every Java class must perform a single functionality.
If our class is doing more than one responsibility, Then we should split our class in such a manner,
That one class has only one responsibility and others have other responsibilities, Else we are violating SRP.

Bad example:
	data class Employee(
	    var empId: String,
	    var empName: String,
	    var empPhoneNumber: String,

	    var empCtc: String,
	    var empTakeHome: String,
	    var empTax: String,

	    var addressLine: String,
	    var landmark: String,
	    var pinCode: String,
	    var city: String,
	    var state: String
	) {

	    fun getEmpBasicInformation() {
	        println("Emp Id: $empId")
	        println("Emp name: $empName")
	        println("Emp name: $empName")
	        println("Emp PhoneNumber: $empPhoneNumber")
	    }

	    fun getEmpSalaryInformation() {
	        println("Emp ctc: $empCtc")
	        println("Emp take home: $empTakeHome")
	        println("Emp tax: $empTax")
	    }

	    fun getEmpAddressInformation() {
	        println("Emp address: $addressLine,$landmark,$city,$pinCode,$state")
	    }

	}

	Here Employee class is managing more than one responsibility.
	1 Employee info, 2 Ctc Info, 3 Address info.
	So updating any of this will take more time as well as in more places, We need to maintain the code, and if we want to reuse one of the subparts so it is not reusable.

Good example:
	data class EmployeeDetail(
	    val employee: Employee,
	    val employeeCTC: EmployeeCTC,
	    val employeeAddress: EmployeeAddress
	) {
	    fun getEmployee() {
	        employee.getEmpBasicInformation()
	    }

	    fun getEmployeeCTC() {
	        employeeCTC.getEmpCTCInformation()
	    }

	    fun getEmployeeAddress() {
	        employeeAddress.getEmpAddressInformation()
	    }
	}

	data class Employee(
	    var empId: String,
	    var empName: String,
	    var empPhoneNumber: String
	) {
	    fun getEmpBasicInformation(): String {
	        return "Employee(empId='$empId'," +
	                " empName='$empName', " +
	                "empPhoneNumber='$empPhoneNumber')"
	    }
	}

	data class EmployeeCTC(
	    var empCtc: String,
	    var empTakeHome: String,
	    var empTax: String
	) {
	    fun getEmpCTCInformation(): String {
	        return "EmployeeCTC(empCtc='$empCtc'," +
	                " empTakeHome='$empTakeHome', " +
	                "empTax='$empTax')"
	    }
	}

	data class EmployeeAddress(
	    var addressLine: String,
	    var landmark: String,
	    var pinCode: String,
	    var city: String,
	    var state: String
	) {
	    fun getEmpAddressInformation(): String {
	        return "EmployeeAddress(addressLine='$addressLine'," +
	                " landmark='$landmark'," +
	                " pinCode='$pinCode', " +
	                "city='$city', state='$state')"
	    }
	}

	Above we have separated each class as a responsibility, So the code is cleaner and readable, and maintainable, If we want to use any of the classes independently in many places we can do it easily, and If we want to update any class so it is much easier now.


==> Open-Closed Principle (OCP)
This principle states that “Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”

Bad example:
    class PaymentProcessor {
        fun processPayment(type: String, amount: Double) {
            when (type.lowercase()) {
                "cash" -> println("Paid $$amount using Cash")
                "card" -> println("Paid $$amount using Credit Card")
                "paypal" -> println("Paid $$amount using PayPal")
                else -> println("Unsupported payment method: $type")
            }
        }
    }
    ---Usage---
	fun main() {
        val processor = PaymentProcessor()

        processor.processPayment("cash", 100.0)
        processor.processPayment("card", 250.0)
        processor.processPayment("paypal", 500.0)
    }

Good example:
    1. Define a Common Interface (Abstraction)
    interface PaymentMethod {
        fun pay(amount: Double)
    }

    2. Implement Different Payment Types (Extension)
    class CashPayment : PaymentMethod {
        override fun pay(amount: Double) {
            println("Paid $$amount using Cash")
        }
    }

    class CreditCardPayment : PaymentMethod {
        override fun pay(amount: Double) {
            println("Paid $$amount using Credit Card")
        }
    }

    class PayPalPayment : PaymentMethod {
        override fun pay(amount: Double) {
            println("Paid $$amount using PayPal")
        }
    }

    3. POS Payment Processor (Closed for Modification)
    class PaymentProcessor {
        fun processPayment(paymentMethod: PaymentMethod, amount: Double) {
            paymentMethod.pay(amount)
        }
    }

    ---Usage---
    fun main() {
        val pos = PaymentProcessor()

        val cash = CashPayment()
        val card = CreditCardPayment()
        val paypal = PayPalPayment()

        pos.processPayment(cash, 100.0)
        pos.processPayment(card, 250.0)
        pos.processPayment(paypal, 500.0)
    }


==> Liskov Substitution Principle (LSP)
According to this principle “Derived or child classes must be substitutable for their base or parent classes“.
Parent classes should be easily substituted with their child classes without changing the behaviour of the parent classes. It means that a subclass should override the methods from a parent class, which does not break the functionality of the parent class.

This becomes important when we use inheritance, We always need to check if the child class is a proper subset of a parent class then only we should use inheritance otherwise we are breaking LSP.

Bad Example:
    Let’s say someone decides to throw an exception for discounts in a subclass that should follow the base class’s rules.
    class NoDiscountProduct(name: String, price: Double) : Product(name, price) {
        override fun getFinalPrice(): Double {
            throw UnsupportedOperationException("Discount not supported")
        }
    }
    Now
    val product: Product = NoDiscountProduct("Membership", 200.0)
    println(product.getFinalPrice()) // 💥 CRASHES!

    That violates LSP — because NoDiscountProduct can’t be safely substituted for Product.

Good Example:
    1. Base Class
    open class Product(val name: String, val price: Double) {
        open fun getFinalPrice(): Double = price
    }

    2. Subclass: Discountable Product
    class DiscountedProduct(name: String, price: Double, val discountPercent: Double)
        : Product(name, price) {

        override fun getFinalPrice(): Double {
            return price - (price * discountPercent / 100)
        }
    }

    3. Subclass: Fixed Price Product (no discount)
    class FixedPriceProduct(name: String, price: Double) : Product(name, price)

    4. You Can Substitute Any Product Type
    fun printReceipt(products: List<Product>) {
        for (product in products) {
            println("${product.name}: $${product.getFinalPrice()}")
        }
    }

    ---Usage---
    fun main() {
        val items = listOf(
            DiscountedProduct("T-Shirt", 50.0, 10.0),
            FixedPriceProduct("Gift Card", 100.0),
            DiscountedProduct("Shoes", 120.0, 20.0)
        )

        printReceipt(items)
    }


==> Interface Segregation Principle (ISP)
It states that “do not force any client to implement an interface which is irrelevant to them“. 

Bad Example:
    interface POSDevice {
        fun printReceipt(data: String)
        fun scanBarcode(): String
        fun processCard(amount: Double)
    }
    Now imagine you create a BarcodeScanner class:
    class BarcodeScanner : POSDevice {
        override fun printReceipt(data: String) {
            throw UnsupportedOperationException("Not supported")
        }

        override fun scanBarcode(): String {
            return "123456789"
        }

        override fun processCard(amount: Double) {
            throw UnsupportedOperationException("Not supported")
        }
    }
    😬 Ugh! This class is forced to implement methods it doesn’t use. That’s a direct violation of ISP.

Good example:
    1. Break interfaces into smaller, specific ones
    interface ReceiptPrinter {
        fun printReceipt(data: String)
    }

    interface BarcodeScanner {
        fun scanBarcode(): String
    }

    interface CardReader {
        fun processCard(amount: Double)
    }

    2. Implement only what each device needs
    class ThermalPrinter : ReceiptPrinter {
        override fun printReceipt(data: String) {
            println("Printing receipt: $data")
        }
    }

    class USBBarcodeScanner : BarcodeScanner {
        override fun scanBarcode(): String {
            return "123456789"
        }
    }

    class NFCReader : CardReader {
        override fun processCard(amount: Double) {
            println("Processing card payment of $$amount")
        }
    }

    ---Usage---
    fun processPOS(printer: ReceiptPrinter?, scanner: BarcodeScanner?, cardReader: CardReader?) {
        scanner?.scanBarcode()?.let { println("Scanned product: $it") }
        cardReader?.processCard(99.99)
        printer?.printReceipt("Total: $99.99")
    }

    fun main() {
        val printer = ThermalPrinter()
        val scanner = USBBarcodeScanner()
        val reader = NFCReader()

        processPOS(printer, scanner, reader)
    }


==> Dependency Inversion Principle (DIP)
This principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions and Abstractions should not depend upon details. Details should depend upon abstractions.

Bad Example:
    class PaymentProcessor {
        fun process(amount: Double) {
            val cardPayment = CardPayment()
            cardPayment.pay(amount)
        }
    }

    class CardPayment {
        fun pay(amount: Double) {
            println("Paid $$amount using Card")
        }
    }
    😬 Problems:
    PaymentProcessor (high-level) directly depends on CardPayment (low-level).
    Can't switch to PayPalPayment or CashPayment without modifying PaymentProcessor.
    Hard to test or extend.

Good example:
     1. Create an abstraction
    interface PaymentMethod {
        fun pay(amount: Double)
    }

    2. Implement low-level classes
    class CardPayment : PaymentMethod {
        override fun pay(amount: Double) {
            println("Paid $$amount using Card")
        }
    }

    class PayPalPayment : PaymentMethod {
        override fun pay(amount: Double) {
            println("Paid $$amount using PayPal")
        }
    }

    3. High-level class depends on abstraction
    class PaymentProcessor(private val paymentMethod: PaymentMethod) {
        fun process(amount: Double) {
            paymentMethod.pay(amount)
        }
    }

    ---Usage---
    fun main() {
        val cardPayment = CardPayment()
        val payPalPayment = PayPalPayment()

        val cardProcessor = PaymentProcessor(cardPayment)
        val paypalProcessor = PaymentProcessor(payPalPayment)

        cardProcessor.process(100.0)
        paypalProcessor.process(200.0)
    }
    ✅ Why This Follows DIP
    PaymentProcessor doesn’t care how the payment is done — it relies on the PaymentMethod interface.
    Low-level modules (CardPayment, PayPalPayment) can be changed without touching PaymentProcessor.
    You can easily add test stubs or mocks for unit testing.