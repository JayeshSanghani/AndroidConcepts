
Jetpack Compose Interview Questions:

-> Jetpack Compose vs Android View System.
-> Explain the concept of declarative UI in Jetpack Compose.
-> Declarative UI vs Imperative UI.
-> What are Composable functions?
-> What is Recomposition?
-> What is State in Compose?
-> How does state management work in Jetpack Compose?
-> Stateful composable vs Stateless composable.
-> What are the side effects?
-> Difference between LaunchedEffect and DisposableEffect.
-> What is rememberCoroutineScope and its use cases?
-> How to observe Flows, and LiveData states in Compose UI?
-> How can we handle asynchronous operations in Jetpack Compose?
-> How can we convert a non-compose state into a Compose state?
-> Explain derivedStateOf.
-> Explain rememberUpdatedState.
-> Difference between remember and rememberSaveable.
-> Explain the Lifecycle of a Composable in Jetpack Compose.
-> How do you handle lifecycle events in Compose functions?
-> What are the best practices for performance optimization in Jetpack Compose?
-> Can we use both Jetpack Compose and Android View in a Single App?
-> What is State Hoisting?
-> Explain CompositionLocal.
-> Explain Jetpack Compose Phases.
-> What is the role of the Modifier in Jetpack Compose?
-> What are Semantics?
-> How can you handle user input and events in Jetpack Compose?
-> How do you handle navigation in Jetpack Compose?
-> How do you handle orientation changes in Jetpack Compose?
-> Explain the concept of unidirectional data flow in Jetpack Compose.
-> How to create Custom Layouts in Compose?



-> What are Dispatchers and Name all of them
-> On which thread Dispatchers .Default execute the task or use which thread?
-> Dispatchers .Default vs Dispatcher .IO
-> What is SupervisorScope?
-> Exception Handling in Coroutine
-> What is ViewModelScope and How does it work internally?
-> What is Clean Architecture in MVVM
-> What are Provides and Binds in your Dagger library
-> Map vs FlatMap in kotlin
-> Singleton Pattern in Kotlin with object keyword
-> Collections API in Kotlin
-> MVVM vs MVI
-> What is Unidirectional Flow
-> StateFlow vs SharedFlow
-> Builder Pattern in Kotlin
-> Higher Order Functions in Kotlin
-> Covariance in Kotlin
-> When does ViewModel not survive
-> What is process death?
-> What does the Signed APK mean?
-> What is Deep and Shallow Copy?
-> What is Intent Service?
-> What is R8?
-> What is Frozen Frame?
-> What are App Bundles?
-> What is Obfuscation?
-> How to store local Secret Keys?
-> What is a secret .properties file?
-> What is Single Sign-Off?
-> How can you create or use an Android Device ID?
-> How do you figure out the User using the different Devices?
-> What is Product Flavor?
-> What is Build Flavor?
-> What is Protobuf?
-> What is SSL Pinning?
-> What is Heap and Stack Memory?
-> Destructuring declaration



-> Coroutine
Coroutine is concurrency design pattern that we can use on android to simplify the code that execute asynchronously.
Coroutine helps to manage long running task that might otherwise block main thread and cause your app to become unresponsive.

-> Why Use Dispatchers?
	-UI Responsiveness: Offloading heavy or long-running tasks to Dispatchers.IO or Dispatchers.Default ensures the main thread remains responsive.
	-Performance: Dispatchers efficiently manage threads, reducing overhead and improving app performance.
	-Thread-Safe Concurrency: Ensures tasks execute in the correct thread context.


-> Switching Between Dispatchers
	You can switch between dispatchers using withContext. This allows you to perform background work on one dispatcher (e.g., IO) and then update the UI on the Main dispatcher.
	Example:
	fun fetchDataAndDisplay() {
	    CoroutineScope(Dispatchers.Main).launch {
	        val data = withContext(Dispatchers.IO) { 
	            fetchDataFromDatabase() // Background thread
	        }
	        textView.text = data // Main thread
	    }
	}


-> Kotlin provides three dispatchers to specify where the coroutine should run.

1) Dispatchers.Main
2) Dispatchers.IO
3) Dispatchers.Default
4) Dispatchers.Unconfined


1) Dispatchers.Main
	-Main should be used any for Interacting with UI and performing quick work.
	-Typically used for tasks that interact with the UI (e.g., updating views or handling user input).
	Example:
	launch(Dispatchers.Main) {
    // Code here runs on the main thread
	    textView.text = "Hello from the Main Thread!"
	}

2) Dispatchers.IO
	-IO is optimized perform disk or network I/O outside of the Main thread.
	-It uses a shared thread pool, designed for blocking operations.
	Example:
	launch(Dispatchers.IO) {
	    val data = fetchDataFromNetwork() // Simulated I/O operation
	    withContext(Dispatchers.Main) {
	        textView.text = data // Switch back to the main thread
	    }
	}

3) Dispatchers.Default
	-Default  is optimized to perform cpu intensive work outside to the main thread.
	-Executes coroutines on a shared pool of background threads.
	Example:
	launch(Dispatchers.Default) {
	    val result = performHeavyComputation()
	    withContext(Dispatchers.Main) {
	        textView.text = result
	    }
	}

4) Dispatchers.Unconfined
	Starts the coroutine in the caller’s thread but does not confine it to a specific thread. 
	It may resume on a different thread.Typically used for debugging or specific scenarios where 
	thread confinement isn’t needed.
	Example:
	launch(Dispatchers.Unconfined) {
	    println("Running on thread: ${Thread.currentThread().name}")
	}

-> Coroutine builers
1) launch	
	Purpose: Launches a new coroutine without returning a result (fire-and-forget).
	Returns: Job	
	Use Case: Fire-and-forget tasks.
	UI updates, background tasks, or other independent operations.
	Example:
	fun main() = runBlocking {
	    val job = launch {
	        println("Coroutine launched!")
	        delay(1000L)
	        println("Task complete!")
	    }
	    println("Waiting for job...")
	    job.join() // Wait for the coroutine to finish
	    println("Job finished.")
	}

2) async
	Purpose: Launches a new coroutine that returns a result (similar to Future or Promise).	
	Returns: Deferred<T>	T
	Use Case: asks that need to return a result. 
	Calculations, API calls, or any task needing a result.
	Example:
	fun main() = runBlocking {
	    val deferred = async {
	        delay(1000L)
	        "Hello from async!"
	    }
	    println("Waiting for result...")
	    println("Result: ${deferred.await()}")
	}

3) runBlocking	
	Purpose: Bridges regular blocking code with coroutines.
	Returns: Nothing	
	Use Case: Blocking code integration/testing. 
	Testing coroutine code or scripting.
	Example:
	fun main() {
	    runBlocking {
	        println("Start of runBlocking")
	        launch {
	            delay(500L)
	            println("Coroutine inside runBlocking")
	        }
	        println("End of runBlocking")
	    }
	}


4) withContext	
	Purpose: Switches the coroutine to a different dispatcher/context.
	Returns: Result of block	
	Use Case: Switching dispatcher/context.
	Example:
	fun main() = runBlocking {
	    println("Running on thread: ${Thread.currentThread().name}")
	    withContext(Dispatchers.IO) {
	        println("Switched to IO dispatcher on thread: ${Thread.currentThread().name}")
	    }
	    println("Back to main thread: ${Thread.currentThread().name}")
	}

5) produce
	Purpose: Creates a coroutine that produces a stream of values using a channel.
	Returns: ReceiveChannel	
	Use Case: Producing streams of values.
	Example:
	fun main() = runBlocking {
	    val producer = produce {
	        for (i in 1..5) {
	            send(i) // Send values to the channel
	            delay(500L)
	        }
	    }
	    for (value in producer) {
	        println("Received: $value")
	    }
	}


-> Coroutine scopes










