->MVVM (Model-View-ViewModel) is a software architectural pattern commonly used in Android development.
It separates the application into three main components:

1)Model: Represents the data and business logic. It manages the data, fetching it from databases or APIs.
2)View: Displays the data and receives user input, but does not contain logic.
3)ViewModel: Acts as a mediator between the View and Model. It holds the logic, processes the data,
and exposes it in a format that the View can display.


->Why is MVVM Used?
1)Lifecycle Awareness: In Android, the ViewModel is lifecycle-aware, reducing memory leaks and ensuring efficient handling of UI-related data.
2)Separation of Concerns: By decoupling the UI from the business logic, MVVM makes the code cleaner and easier to maintain.
3)Scalability: MVVM makes it simpler to scale applications by maintaining a clear distinction between layers.
4)Testability: Business logic is moved to the ViewModel, making it easier to write unit tests.


->When to Use MVVM:
When managing complex UIs with a lot of user interactions, dynamic data, and configuration changes.
When data persistence across configuration changes is important.
When building scalable, testable, and maintainable applications, where you need clean separations of
UI and data-handling logic.


->Key Concepts in Android MVVM:
1)Data Binding: Androidâ€™s Data Binding Library can be used to bind the ViewModel data directly to UI components in XML.
This reduces the amount of boilerplate code for updating the UI when the data changes.
2)LiveData: LiveData is a lifecycle-aware observable data holder used in the ViewModel. It allows the View to observe
changes in the data and update the UI automatically when the data is updated.
3)Repository Pattern: Often, the Model layer uses a Repository to abstract data access. A repository handles fetching
data from multiple sources like a remote API or a local database.


->How MVVM Works
1)ViewModel Fetches Data: The ViewModel interacts with the Repository (part of the Model) to fetch data.
2)LiveData Updates View: The ViewModel exposes data as LiveData, which the View observes. When data changes, the UI updates automatically.
3)User Interaction: User actions are passed from the View to the ViewModel, which handles the logic.


->Advantages of MVVM
Reduced Code in Activity/Fragment: All business logic is in the ViewModel, keeping the View lightweight.
Reactive Updates: Changes in the Model automatically reflect in the UI.
Lifecycle Awareness: Android's ViewModel survives configuration changes like screen rotations.

->Disadvantages of MVVM
Steeper Learning Curve: For developers new to architectural patterns.
Boilerplate Code: Can result in additional code for simple applications.


1)Presentation Layer
Purpose:
	Contains UI logic (Activity/Fragment) and observes changes from ViewModel.
Classes:
	->LoginActivity (or LoginFragment):
		Acts as the View.
		Observes LiveData from the LoginViewModel and updates the UI accordingly.


	class LoginActivity : AppCompatActivity() {
	    private val viewModel: LoginViewModel by viewModels {
	        LoginViewModelFactory(LoginUseCase(LoginRepository()))
	    }

	    override fun onCreate(savedInstanceState: Bundle?) {
	        super.onCreate(savedInstanceState)
	        setContentView(R.layout.activity_login)

	        val usernameEditText: EditText = findViewById(R.id.editTextUsername)
	        val passwordEditText: EditText = findViewById(R.id.editTextPassword)
	        val loginButton: Button = findViewById(R.id.buttonLogin)
	        val progressBar: ProgressBar = findViewById(R.id.progressBar)

	        // Observe login result
	        viewModel.loginResult.observe(this) { result ->
	            progressBar.visibility = View.GONE
	            if (result.isSuccessful) {
	                Toast.makeText(this, "Login Successful!", Toast.LENGTH_SHORT).show()
	                // Navigate to next screen
	            } else {
	                Toast.makeText(this, "Login Failed: ${result.errorMessage}", Toast.LENGTH_SHORT).show()
	            }
	        }

	        // Handle login button click
	        loginButton.setOnClickListener {
	            progressBar.visibility = View.VISIBLE
	            val username = usernameEditText.text.toString()
	            val password = passwordEditText.text.toString()
	            viewModel.login(username, password)
	        }
	    }
	}

	->LoginViewModel:
		Provides data and handles logic for the View.
		Calls the LoginUseCase to perform the login operation.

	class LoginViewModel(private val loginUseCase: LoginUseCase) : ViewModel() {
	    private val _loginResult = MutableLiveData<LoginResult>()
	    val loginResult: LiveData<LoginResult> = _loginResult

	    fun login(username: String, password: String) {
	        viewModelScope.launch {
	            val result = loginUseCase.execute(username, password)
	            _loginResult.value = result
	        }
	    }
	}

2)Domain Layer
Purpose:
	Contains business logic and use cases.
	Decoupled from the data source.
Classes:
	->LoginUseCase:
		Executes the login operation by calling the LoginRepository.
		class LoginUseCase(private val loginRepository: LoginRepository) {
		    suspend fun execute(username: String, password: String): LoginResult {
		        return loginRepository.login(username, password)
		    }
		}

	->LoginResult:
		Represents the outcome of the login operation..

	data class LoginResult(val isSuccessful: Boolean, val errorMessage: String? = null)

3)Data Layer
Purpose:
	Manages data sources (local or remote) and handles fetching/saving data.
Classes:
	->LoginRepository:
		Acts as the entry point to data operations.
		Fetches data from remote (e.g., server via API) or local (e.g., Room).
		class LoginRepository {
		    private val remoteDataSource = RemoteDataSource()
		    private val localDataSource = LocalDataSource()

		    suspend fun login(username: String, password: String): LoginResult {
		        // Example logic: Try remote login, fall back to local cache
		        val remoteResult = remoteDataSource.login(username, password)
		        return if (remoteResult.isSuccessful) {
		            localDataSource.saveUserData(username, password) // Cache data locally
		            remoteResult
		        } else {
		            remoteResult
		        }
		    }
		}


	->RemoteDataSource:
		Handles API requests (e.g., Retrofit).
		class RemoteDataSource {
		    suspend fun login(username: String, password: String): LoginResult {
		        // Simulate API call
		        return if (username == "test" && password == "password") {
		            LoginResult(true)
		        } else {
		            LoginResult(false, "Invalid credentials")
		        }
		    }
		}

	->LocalDataSource:
		Handles local database operations (e.g., Room).
		class LocalDataSource {
		    fun saveUserData(username: String, password: String) {
		        // Save to Room or SharedPreferences
		    }
		}


->How Data Flows in the Architecture
	User Action:
		The user enters credentials in the LoginActivity and clicks the login button.
	ViewModel Logic:
		LoginActivity calls LoginViewModel.login(), which triggers the LoginUseCase.
	Domain Logic:
		The LoginUseCase interacts with the LoginRepository.
	Data Layer:
		The LoginRepository fetches the data from RemoteDataSource (API) or LocalDataSource (cache).
	Result to UI:
		The LoginResult flows back to the ViewModel, which updates the LiveData. 
		The Activity observes this and updates the UI.


